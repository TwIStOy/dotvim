global !p
from cpp_snippet_helper import *
from header_include_helper import generate_cpp_header_filename

def output_stream_generate(matched_str, snip):
	args = [it.strip() for it in str(matched_str).split(',')]
	snip.rv = ' << ", " << '.join(['"%s: " << %s' % (it, it) for it in args])

def output_stream_generate_pair(matched_str, snip):
	args = [it.strip() for it in str(matched_str).split(',')]
	tmp = ' << ", " << '.join(['"%s: " << %s' % (it, it) for it in args])
	snip.rv = '"(" << ' + tmp + ' << ")"'

def output_format_generate(matched_str, snip):
	args = [it.strip() for it in str(matched_str).split(',')]
	fmt_str =  ', '.join(["%s: {}" % (it) for it in args])
	args_str = ', '.join(args)
	snip.rv = '"{}"_format({})'.format(fmt_str, args_str)

endglobal

priority -50

snippet "(\w[\d\w, .\->_]*?)\.oss" "convert to output stream ..." r
`!p output_stream_generate(match.group(1), snip)`$0
endsnippet

snippet "\(([\d\w, .\->_]*?)\)\.oss" "convert to output stream with pair ..." r
`!p output_stream_generate_pair(match.group(1), snip)`$0
endsnippet

snippet "(\w[\d\w,\s\->._]*?)\.fmt" "convert to fmt style" r
`!p output_format_generate(match.group(1), snip)`${0}
endsnippet

snippet ns "namespace with comment (namespace)" b
namespace ${1:`!p snip.rv = snip.basename or "name"`} {
  ${0:/* body */}
}${1/.+/  \/\/ namespace /m}$1
endsnippet

snippet once "pragma once (pragma)" "all_lines_before_are_comments(snip)" bAe
#pragma once  // NOLINT(build/header_guard)

${0}
endsnippet

snippet cr "copyright" "snip.line == 0" bAe
// Copyright (c) 2020 - present, `!p snip.rv = license_name(os.path.abspath(path))`
//

${0}
endsnippet

# simple snippets {{{
snippet dc "dynamic_cast" w
dynamic_cast<${1}>(${2})${0}
endsnippet

snippet cc "const_cast" w
const_cast<${1}>(${2})${0}
endsnippet

snippet #" "include" bA
#include "${1}"${0}
endsnippet

snippet #< "system include" bA
#include <${1}>${0}
endsnippet

snippet map "std::map" w
std::map<${1:key}, ${2:value}> ${0:name};
endsnippet

snippet umap "std::unordered_map" w
std::unordered_map<${1:key}, ${2:value}> ${0:name};
endsnippet

snippet vec "std::vector" w
std::vector<${1:type}> ${0:name};
endsnippet

snippet uptr "std::unique_ptr" w
std::unique_ptr<${1:type}>(new $1{${2:args}})${0}
endsnippet

snippet todo "TODO comments" bA
// TODO(hawtian): ${0}
endsnippet

snippet fixme "FIXME comments" bA
// FIXME(hawtian): ${0}
endsnippet

snippet tn "typename" w
typename ${1:T}${0}
endsnippet

snippet tns "typenames..." w
typename... ${1:Args}${0}
endsnippet

snippet tp "template..." w
template<${0}>
endsnippet

snippet try "try-catch block" b
try {
	${1:/* block */}
} catch (${2:const std::exception& e}) {
	${0:std::cerr << e.what() << std::endl;}
}
endsnippet

snippet [] "lambda function" b
[&](${1:Args}) {
	${0}
}
endsnippet

# }}}

snippet getter "getter..." b
/**
 * @return auto current `!p snip.rv = underscore_to_big_camel_case(t[1])`
 */
inline __attribute__((always_inline)) const auto& Get`!p snip.rv = underscore_to_big_camel_case(t[1])`() const {
  return ${1};
}
endsnippet

snippet getset "getter and setter..." b
/**
 * @return $1 current $2
 */
inline __attribute__((always_inline)) ${1:TYPE} `!p snip.rv = underscore_to_big_camel_case(t[2])`() const {
  return ${2:NAME};
}

/**
 * Set current $2
 * @param v new value of $2
 */
inline __attribute__((always_inline)) void `!p snip.rv = underscore_to_big_camel_case(t[2])`($1 v) {
  $2 = std::move(v);
}
endsnippet

snippet ll "LLOG(Info, ...)" bA
LLOG(Info, ${0});
endsnippet

# common types-alias
snippet "(p(?:(?:(?=\()\([pius0-9\()]+\s*(?:,\s*[pius0-9()]+)+\))|[ius]{2}))" "convert to std::pair or tuple format..." r
`!p snip.rv = short_nameset_parse(match.group(1))`$0
endsnippet

snippet #h "include corresponding header..." bA
`!p snip.rv = generate_cpp_header_filename(vim)`$0
endsnippet

snippet cons "current struct's default-constructor" "nearest_struct_name(snip)" be
`!p snip.rv = context`(${1});${0}
endsnippet

snippet ccons "current struct's copy-constructor" "nearest_struct_name(snip)" be
`!p snip.rv = context`(const `!p snip.rv = context`&) = default;${0}
endsnippet

snippet mcons "current struct's move-constructor" "nearest_struct_name(snip)" be
`!p snip.rv = context`(`!p snip.rv = context`&&) = default;${0}
endsnippet

snippet des "current struct's destructor" "nearest_struct_name(snip)" be
~`!p snip.rv = context`() = default;${0}
endsnippet

snippet coreturn "co_return shortcut" bA
co_return 
endsnippet

snippet coawait "co_return shortcut" bA
co_await 
endsnippet

snippet coyield "co_return shortcut" bA
co_yield 
endsnippet

snippet "ns\s+([\w_]+(::[\w_]+)*)" "simple namespace generator..." r
namespace `!p snip.rv = match.group(1)` {
${0:  /* body */}
}  // namespace `!p snip.rv = match.group(1)`
endsnippet

snippet itf "cpp interface common" b
struct ${1:InterfaceName} {
	virtual ~$1() = default;

	${0}
};
endsnippet

snippet vf "virtual function" b
virtual ${3:ReturnType} ${1:FunctionName}(${2:args})${0};
endsnippet

snippet pvf "pure virtual function" b
virtual ${3:ReturnType} ${1:FunctionName}(${2:args}) ${4} = 0;${0}
endsnippet

snippet "\b([iu])((?:8)|(?:16)|(?:32)|(?:64))" "int types..." rA
`!p simple_int_types(match.group(1), match.group(2), snip)` ${0}
endsnippet

post_jump "expand_anon(snip)"
snippet cguard "c styple header guard" b
`!p snip.rv = cpp_c_style_header_guard(path)`
endsnippet

snippet externc "extern c guard for cpp" b
#ifdef __cplusplus
extern "C" {
#endif

${0: /* body */}

#ifdef __cplusplus
}
#endif
endsnippet

snippet fmp "find function in map C++17" b
if (auto it = ${1:map name}.find(${2:key}); it != $1.end()) {
  ${3:exists block}
}
endsnippet

snippet fmp! "find function in map C++17" b
if (auto it = ${1:map name}.find(${2:key}); it == $1.end()) {
  ${3:exists block}
}
endsnippet

snippet traitfun "Implements a type trait that uses inheritance and expression SFINAE to do the heavy work. This is typically used to check if a typedef exists." b
struct _${1:name}Impl {
  template<typename T, ${2:conditions}>
  static std::true_type test(int);
  template<typename...>
  static std::false_type test(...);
};
template<typename T>
struct $1 : decltype(_$1Impl::test<T>(0)) {};
endsnippet

snippet tfmt "formatter for fmt" b
template<>
struct formatter<${1:TypeName}> {
  using ValueType = $1;
  template<typename ParseContext>
  auto parse(ParseContext &ctx) ->  // NOLINT(runtime/references)
      typename ParseContext::iterator {
    return ctx.begin();
  }

  template<typename FormatContext>
  auto format(const ValueType &v,
              FormatContext &ctx)  // // NOLINT(runtime/references)
      -> decltype(ctx.out()) {
		${0}
    return format_to(ctx.out(), "{}", v);
  }
};
endsnippet

snippet clanggreater "Checks for Clang version definition greater than or equal to version specified (version $1.$2)." b
defined(__clang__) && ((__clang_major__ > ${1:MajorVersion}) || (__clang_major__ == $1) && (__clang_minor__ >= ${2:MinorVersion}))
endsnippet

snippet clangless "Checks for Clang version definition less than or equal to version specified (version $1.$2)." b
defined(__clang__) && ((__clang_major__ < ${1:MajorVersion}) || (__clang_major__ == $1) && (__clang_minor__ <= ${2:MinorVersion}))
endsnippet

snippet gccgreater "Checks for GCC version definition greater than or equal to version specified (version $1.$2.0)" b
defined(__GNUC__) && ((__GNUC__ > ${1:MajorVersion}) || ((__GNUC__ == $1) && (__GNUC_MINOR__ >= ${2:MinorVersion})))
endsnippet

snippet gccless "Checks for GCC version definition less than or equal to version specified (version $1.$2.0)" b
defined(__GNUC__) && ((__GNUC__ < ${1:MajorVersion}) || ((__GNUC__ == $1) && (__GNUC_MINOR__ <= ${2:MinorVersion})))
endsnippet

snippet functor "Functor class" b
struct ${1:Name} {
	${2:Ret} operator()(${3:Args}) const noexcept {
		$0
	}
};
endsnippet

snippet inher "inherit comment" b
// inherited from |$0|
endsnippet

snippet awaiter "awaiter template" b
struct awaiter {
	bool await_ready() const noexcept {
		return false;
	}

	template<typename P>
	void await_suspend(std::coroutine_handle<P> co) const noexcept {
	}

	void await_resume() noexcept {
	}
};
endsnippet

snippet cpp20 "macro greater cpp20" b
#if __cplusplus >= 202002L
${0}
#endif
endsnippet

# vim: set fdm=marker

