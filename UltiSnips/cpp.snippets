global !p
from cpp_snippet_helper import *

def write_docstring_args(arglist, snip):
	args = str(arglist).split(',')

	if len(args) > 1:
		c = 0
		for arg in args:
			if c == 0:
				snip.rv += arg
				c = 1
			else:
				snip += ' * @param %s' % arg.strip()
	else:
		snip.rv = args[0]

def defined_class_name(snip):
	basename = snip.basename
	if basename:
		snip.rv = "".join([it.capitalize() for it in basename.split('_')])
	else:
		snip.rv = "name"

def output_stream_generate(matched_str, snip):
	args = [it.strip() for it in str(matched_str).split(',')]
	snip.rv = " << ".join(['"%s: " << %s' % (it, it) for it in args])

def output_stream_generate_pair(matched_str, snip):
	args = [it.strip() for it in str(matched_str).split(',')]
	tmp = " << ".join(['"%s: " << %s' % (it, it) for it in args])
	snip.rv = '"(" << ' + tmp + ' << ")"'

def pair_generate(matched_first, matched_second, snip):
	hello()
	def fullname(s):
		if s == "s":
			return "std::string"
		elif s == "i":
			return "int"
		elif s == "u":
			return "uint32_t"
		elif s == "ii":
			return "int64_t"
		elif s == "uu":
			return "uint64_t"
		else:
			return ""
	snip.rv = "std::pair<{}, {}>".format(fullname(matched_first),
																		   fullname(matched_second))
endglobal

snippet fnc "c++ function with doxygen comment" b
/**
 * @brief ${4:brief}
 *
 * @param `!p write_docstring_args(t[3],snip)`
 *
 * @return `!p snip.rv = t[1]`
 */
${1:ReturnType} ${2:FunctionName}(${3:param});
endsnippet

snippet cls "class ... (class)" b
class ${1:`!p defined_class_name(snip)`} {
 public:
  $1(${2:args});
	virtual ~$1() = default;

 private:
};
endsnippet

snippet "(\w[\w, ]*?).oss" "convert to output stream ..." r
`!p output_stream_generate(match.group(1), snip)`$0
endsnippet

snippet "\(([\w, ]*?)\).oss" "convert to output stream with pair ..." r
`!p output_stream_generate_pair(match.group(1), snip)`$0
endsnippet

snippet "(\w[\w, ]*?).p" "comment" b
`!p snip.rv = "(" + match.group(1) + ")"`
endsnippet

snippet ns "namespace with comment (namespace)"
namespace${1/.+/ /m}${1:`!p snip.rv = snip.basename or "name"`} {
  ${0:/* body */}
}${1/.+/  \/\/ namespace /m}$1
endsnippet

snippet beginend "$1.begin(), $1.end() (beginend)"
${1:v}${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}begin(), $1${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}end()
endsnippet

snippet once "pragma once (pragma)"
#pragma once  // NOLINT(build/header_guard)
endsnippet

snippet copyright "copyright"
// Copyright (c) 2019 ${1}
//

${0}
endsnippet

snippet sc "static_cast"
static_cast<${1}>(${2})${0}
endsnippet

snippet dc "static_cast"
dynamic_cast<${1}>(${2})${0}
endsnippet

snippet rc "reinterpret_cast"
reinterpret_cast<${1}>(${2})${0}
endsnippet

snippet cc "const_cast"
const_cast<${1}>(${2})${0}
endsnippet

snippet inc "#include"
#include "${1}"
${0}
endsnippet

snippet incc "#include<>"
#include <${1}>
${0}
endsnippet

snippet fin "for...in"
for (auto& iter : ${1}) {
  ${0}
}
endsnippet

snippet cfin "const...for...in"
for (const auto& iter : ${1}) {
  ${0}
}
endsnippet

snippet map "std::map"
std::map<${1:key}, ${2:value}> ${0:name};
endsnippet

snippet umap "std::unordered_map"
std::unordered_map<${1:key}, ${2:value}> ${0:name};
endsnippet

snippet vec "std::vector"
std::vector<${1:type}> ${0:name};
endsnippet

snippet nuptr "std::unique_ptr"
std::unique_ptr<${1:type}>(new $1{${2:args}})${0}
endsnippet

# commom words
snippet u32 "uint32_t"
uint32_t
endsnippet

# common types-alias
snippet () "comment" b
body
endsnippet

snippet "(\w{1,2})(\w{1,2}).p" "convert to std::pair format..." r
`!p pair_generate(match.group(1), match.group(2), snip)`$0
endsnippet

snippet "p((?:(?=\()\(\w+\s*(?:,\s*\w+)+\))|(?:i|u|s){2})" "convert to std::pair or tuple format..." r
`!p snip.rv = short_nameset_parse(match.group(1))`$0
endsnippet


